//HintName: Indices.g.cs
// <auto-generated>
// This code was generated by EnumGenerator.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Tests;

public static class IndicesGen
{
	private static readonly Tests.Indices _definedBits =
		Tests.Indices.None |
		Tests.Indices.N1 |
		Tests.Indices.N2 |
		Tests.Indices.N3 |
		Tests.Indices.N4 |
		Tests.Indices.N5 |
		Tests.Indices.N6 |
		Tests.Indices.N7 |
		Tests.Indices.N8;

	private static readonly Dictionary<Tests.Indices, string> _stringCache = new()
	{
		{ Tests.Indices.None, "None" },
		{ Tests.Indices.N1, "N1" },
		{ Tests.Indices.N2, "N2" },
		{ Tests.Indices.N3, "N3" },
		{ Tests.Indices.N4, "N4" },
		{ Tests.Indices.N5, "N5" },
		{ Tests.Indices.N6, "N6" },
		{ Tests.Indices.N7, "N7" },
		{ Tests.Indices.N8, "N8" },
	};

	private static readonly Dictionary<Tests.Indices, byte[]> _utf8Cache = new();

	public static IReadOnlyList<Tests.Indices> Values { get; } = Enum.GetValues<Tests.Indices>();

	public static ReadOnlySpan<byte> NullTerminatedMemberNames => "None\0N1\0N2\0N3\0N4\0N5\0N6\0N7\0N8\0"u8;

	public static string ToStringFast(this Tests.Indices value)
	{
		if (_stringCache.TryGetValue(value, out string? str))
			return str;

		str = GetFlagsString(value);
		_stringCache[value] = str;
		return str;
	}

	private static string GetFlagsString(Tests.Indices value)
	{
		byte raw = (byte)value;
		if (raw == 0)
			throw new ArgumentOutOfRangeException(nameof(value), value, null); // This means 0 is not a defined member, otherwise it would have been cached

		if ((raw & ~(byte)_definedBits) != 0)
			throw new ArgumentOutOfRangeException(nameof(value), value, null);

		List<string> names = new(Values.Count);
		foreach (Tests.Indices item in Values)
		{
			byte itemRaw = (byte)item;
			if (itemRaw != 0 && (raw & itemRaw) == itemRaw)
				names.Add(_stringCache[item]); // Must be present in cache (defined flags are always pre-initialized)
		}

		return string.Join(", ", names);
	}

	public static ReadOnlySpan<byte> AsUtf8Span(this Tests.Indices value)
	{
		if (_utf8Cache.TryGetValue(value, out byte[]? bytes))
			return new ReadOnlySpan<byte>(bytes);

		bytes = Encoding.UTF8.GetBytes(value.ToStringFast());
		_utf8Cache[value] = bytes;
		return new ReadOnlySpan<byte>(bytes);
	}

	public static int GetIndex(this Tests.Indices value)
	{
		return value switch
		{
			Tests.Indices.None => 0,
			Tests.Indices.N1 => 1,
			Tests.Indices.N2 => 2,
			Tests.Indices.N3 => 3,
			Tests.Indices.N4 => 4,
			Tests.Indices.N5 => 5,
			Tests.Indices.N6 => 6,
			Tests.Indices.N7 => 7,
			Tests.Indices.N8 => 8,
			_ => throw new ArgumentOutOfRangeException(nameof(value), value, null),
		};
	}

	public static Tests.Indices FromIndex(int index)
	{
		return index switch
		{
			0 => Tests.Indices.None,
			1 => Tests.Indices.N1,
			2 => Tests.Indices.N2,
			3 => Tests.Indices.N3,
			4 => Tests.Indices.N4,
			5 => Tests.Indices.N5,
			6 => Tests.Indices.N6,
			7 => Tests.Indices.N7,
			8 => Tests.Indices.N8,
			_ => throw new ArgumentOutOfRangeException(nameof(index), index, null),
		};
	}

	public static void Write(this BinaryWriter writer, Tests.Indices value)
	{
		writer.Write((byte)value);
	}

	public static Tests.Indices ReadIndices(this BinaryReader reader)
	{
		return (Tests.Indices)reader.ReadByte();
	}

	public static bool HasFlagFast(this Tests.Indices value, Tests.Indices flag)
	{
		return (value & flag) != 0;
	}
}
